현재 수정되려는 시간대의 데이터가 언제든 다른 요청에 의해 수정될 가능성을 고려하여 해당 데이터에 lock을 겁니다.
무결성을 지키기 위해 걸었지만 다른 요청은 대기 상태에 빠지고, 기존의 lock의 트렌젝션이 커밋 또는 롤백으로 끝나면, 대기하고 있던 요청이 수행되도록 합니다.
하지만 이 방식은 서버 성능에 따라 처리 량이 달라지기에 도입 전 최소 처리 tps에 부합하는지 확인이 필요합니다.

위 방법은 3가지로 적용할 수 있습니다.
1. DB에서 제공하는 데이터 Lock수준을 높인다 - 일반적인 Repeatable Read를 Serializer이상 수준으로 올려 강도 높은 lock으로 완전한 일관성을 유지합니다. 하지만 다른 요청들이 모두 취소되기에 취소된 작업들의 재 시도를 위한 처리가 필요합니다.

2. select for update를 활용하여 명시적 lock을 잡는다. - 이 방법 또한 lock을 잡는 구간이 길어져 성능에 저하가 발생할 수 있습니다.

3. 데이터 트렌젝션의 write lock을 활용합니다 - 일반적으로 데이터 수정 시, write lock이 걸리고 트렌젝션이 끝나야 lock이 풀리는 것을 이용합니다. 데이터 일관성을 유지할 수 있는 가장 현실적인 방법입니다. 이 방법의 경우 또한 DB와 서버 성능에 따라 서비스 속도가 결정됩니다.

4. 데이터 수정 시, 현재 입력을 번호로 입력하는 컬럼 또는 DB를 추가로 구성합니다. 요청이 들어올 때 시간을 순사를 또는 1,2 와 같이 1씩 증가하거나 현재시간으로 갱신하게 해줍니다. 값을 수정할 때 동일한 번호면 수정이 가능해지고, 동일하지 않으면 수정에 실패합니다.


1-1. 현재 사용하는 서버와 구글 캘린더 또는 슬렉 간 API 가 허용돼있지 않아 요청이 거절돼 메세지를 받지 못한 것으로 생각됩니다. 따라서 현재 각 서버 url별 origin을 허용하는 선언이 필요합니다.
1-2. 현재 서버가 https설정이 돼있지 않아 구글과 슬렉에서 요청을 거부하는 것으로 생각됨. 따라서 https설정이 필요합니다.
1-3. 현재 서버가 django 서버라면, 웹 서버 게이트 웨이 설정을 작성하여 파이썬 스크립트가 웹 서버와 통신하는 인터페이스를 구축 해야합니다.

2. 수신자, 송신 시각, 송신 내용, 수신 여부 4가지 컬럼을 구성한 발송 여부를 판단하는 DB를 구성하여 메세지 API 동작 시, DB 확인 후 현재 메세지에 관한 요청이 이미 처리되었다면 요청을 마치는 로직을 구성합니다.


0. 일 별 소정 근무 시간, 연장 근무시간 및 야간 근무시간, 휴일 근무 시간 컬럼을 DB에 만듭니다.

1. 근무 시작 시간부터 근무 종료 시간의 날짜와 근무 시간을 받아옵니다. 이를 금일 근무 시간이라고 하겠습니다.

2-0. 해당 근무 시간 중 22-6시 내에 근무한 기록이 있다면 야간 근무 시간에 해당 시간만큼 작성하고 금일 근무 시간을 차감합니다.

2-1. 금일 평일이라면, 8시간 내 근무 시간을 소정 근무 시간에 추가합니다. 8시간 이후는 연장 근무시간에 추가 시간을 작성합니다.

2-2. 금일 휴일이라면, 8시간 내 근무 시간을 휴일 근무 시간에 추가합니다. 8시간 이후는 연장 근무 시간에 추가합니다.

3-0. 해당 월의 일 별 작성이 완료됐다면, 월 마감을 계산합니다.

3-1. 소정 근무 시간*통상 임금 + (휴일 근무 시간 + 야간 근무 시간 + 연장 근무 시간)*1.5*통상 임금 = 해당 월 급여

결과적으로
월 급여 = 통상 임금 * {소정 근무시간+(휴일 근무 시간 + 야간 근무 시간 + 연장 근무 시간)*1.5}
입니다.